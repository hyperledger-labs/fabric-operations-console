// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/IBM-Blockchain/fabric-deployer/deployer/components/mustgather"
	v1 "k8s.io/api/core/v1"
)

type Kube struct {
	CreateConfigMapStub        func(string, *v1.ConfigMap) (*v1.ConfigMap, error)
	createConfigMapMutex       sync.RWMutex
	createConfigMapArgsForCall []struct {
		arg1 string
		arg2 *v1.ConfigMap
	}
	createConfigMapReturns struct {
		result1 *v1.ConfigMap
		result2 error
	}
	createConfigMapReturnsOnCall map[int]struct {
		result1 *v1.ConfigMap
		result2 error
	}
	CreateServiceStub        func(string, *v1.Service) (*v1.Service, error)
	createServiceMutex       sync.RWMutex
	createServiceArgsForCall []struct {
		arg1 string
		arg2 *v1.Service
	}
	createServiceReturns struct {
		result1 *v1.Service
		result2 error
	}
	createServiceReturnsOnCall map[int]struct {
		result1 *v1.Service
		result2 error
	}
	DeleteAllPodsMatchingLabelStub        func(string, string) error
	deleteAllPodsMatchingLabelMutex       sync.RWMutex
	deleteAllPodsMatchingLabelArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteAllPodsMatchingLabelReturns struct {
		result1 error
	}
	deleteAllPodsMatchingLabelReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteAndCreatePodStub        func(string, *v1.Pod, string) (*v1.Pod, error)
	deleteAndCreatePodMutex       sync.RWMutex
	deleteAndCreatePodArgsForCall []struct {
		arg1 string
		arg2 *v1.Pod
		arg3 string
	}
	deleteAndCreatePodReturns struct {
		result1 *v1.Pod
		result2 error
	}
	deleteAndCreatePodReturnsOnCall map[int]struct {
		result1 *v1.Pod
		result2 error
	}
	DeleteServiceStub        func(string, string) error
	deleteServiceMutex       sync.RWMutex
	deleteServiceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteServiceReturns struct {
		result1 error
	}
	deleteServiceReturnsOnCall map[int]struct {
		result1 error
	}
	GetPodsByLabelStub        func(string, string) (*v1.Pod, error)
	getPodsByLabelMutex       sync.RWMutex
	getPodsByLabelArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getPodsByLabelReturns struct {
		result1 *v1.Pod
		result2 error
	}
	getPodsByLabelReturnsOnCall map[int]struct {
		result1 *v1.Pod
		result2 error
	}
	GetServiceStub        func(string, string) (*v1.Service, error)
	getServiceMutex       sync.RWMutex
	getServiceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getServiceReturns struct {
		result1 *v1.Service
		result2 error
	}
	getServiceReturnsOnCall map[int]struct {
		result1 *v1.Service
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Kube) CreateConfigMap(arg1 string, arg2 *v1.ConfigMap) (*v1.ConfigMap, error) {
	fake.createConfigMapMutex.Lock()
	ret, specificReturn := fake.createConfigMapReturnsOnCall[len(fake.createConfigMapArgsForCall)]
	fake.createConfigMapArgsForCall = append(fake.createConfigMapArgsForCall, struct {
		arg1 string
		arg2 *v1.ConfigMap
	}{arg1, arg2})
	stub := fake.CreateConfigMapStub
	fakeReturns := fake.createConfigMapReturns
	fake.recordInvocation("CreateConfigMap", []interface{}{arg1, arg2})
	fake.createConfigMapMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) CreateConfigMapCallCount() int {
	fake.createConfigMapMutex.RLock()
	defer fake.createConfigMapMutex.RUnlock()
	return len(fake.createConfigMapArgsForCall)
}

func (fake *Kube) CreateConfigMapCalls(stub func(string, *v1.ConfigMap) (*v1.ConfigMap, error)) {
	fake.createConfigMapMutex.Lock()
	defer fake.createConfigMapMutex.Unlock()
	fake.CreateConfigMapStub = stub
}

func (fake *Kube) CreateConfigMapArgsForCall(i int) (string, *v1.ConfigMap) {
	fake.createConfigMapMutex.RLock()
	defer fake.createConfigMapMutex.RUnlock()
	argsForCall := fake.createConfigMapArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) CreateConfigMapReturns(result1 *v1.ConfigMap, result2 error) {
	fake.createConfigMapMutex.Lock()
	defer fake.createConfigMapMutex.Unlock()
	fake.CreateConfigMapStub = nil
	fake.createConfigMapReturns = struct {
		result1 *v1.ConfigMap
		result2 error
	}{result1, result2}
}

func (fake *Kube) CreateConfigMapReturnsOnCall(i int, result1 *v1.ConfigMap, result2 error) {
	fake.createConfigMapMutex.Lock()
	defer fake.createConfigMapMutex.Unlock()
	fake.CreateConfigMapStub = nil
	if fake.createConfigMapReturnsOnCall == nil {
		fake.createConfigMapReturnsOnCall = make(map[int]struct {
			result1 *v1.ConfigMap
			result2 error
		})
	}
	fake.createConfigMapReturnsOnCall[i] = struct {
		result1 *v1.ConfigMap
		result2 error
	}{result1, result2}
}

func (fake *Kube) CreateService(arg1 string, arg2 *v1.Service) (*v1.Service, error) {
	fake.createServiceMutex.Lock()
	ret, specificReturn := fake.createServiceReturnsOnCall[len(fake.createServiceArgsForCall)]
	fake.createServiceArgsForCall = append(fake.createServiceArgsForCall, struct {
		arg1 string
		arg2 *v1.Service
	}{arg1, arg2})
	stub := fake.CreateServiceStub
	fakeReturns := fake.createServiceReturns
	fake.recordInvocation("CreateService", []interface{}{arg1, arg2})
	fake.createServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) CreateServiceCallCount() int {
	fake.createServiceMutex.RLock()
	defer fake.createServiceMutex.RUnlock()
	return len(fake.createServiceArgsForCall)
}

func (fake *Kube) CreateServiceCalls(stub func(string, *v1.Service) (*v1.Service, error)) {
	fake.createServiceMutex.Lock()
	defer fake.createServiceMutex.Unlock()
	fake.CreateServiceStub = stub
}

func (fake *Kube) CreateServiceArgsForCall(i int) (string, *v1.Service) {
	fake.createServiceMutex.RLock()
	defer fake.createServiceMutex.RUnlock()
	argsForCall := fake.createServiceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) CreateServiceReturns(result1 *v1.Service, result2 error) {
	fake.createServiceMutex.Lock()
	defer fake.createServiceMutex.Unlock()
	fake.CreateServiceStub = nil
	fake.createServiceReturns = struct {
		result1 *v1.Service
		result2 error
	}{result1, result2}
}

func (fake *Kube) CreateServiceReturnsOnCall(i int, result1 *v1.Service, result2 error) {
	fake.createServiceMutex.Lock()
	defer fake.createServiceMutex.Unlock()
	fake.CreateServiceStub = nil
	if fake.createServiceReturnsOnCall == nil {
		fake.createServiceReturnsOnCall = make(map[int]struct {
			result1 *v1.Service
			result2 error
		})
	}
	fake.createServiceReturnsOnCall[i] = struct {
		result1 *v1.Service
		result2 error
	}{result1, result2}
}

func (fake *Kube) DeleteAllPodsMatchingLabel(arg1 string, arg2 string) error {
	fake.deleteAllPodsMatchingLabelMutex.Lock()
	ret, specificReturn := fake.deleteAllPodsMatchingLabelReturnsOnCall[len(fake.deleteAllPodsMatchingLabelArgsForCall)]
	fake.deleteAllPodsMatchingLabelArgsForCall = append(fake.deleteAllPodsMatchingLabelArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteAllPodsMatchingLabelStub
	fakeReturns := fake.deleteAllPodsMatchingLabelReturns
	fake.recordInvocation("DeleteAllPodsMatchingLabel", []interface{}{arg1, arg2})
	fake.deleteAllPodsMatchingLabelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Kube) DeleteAllPodsMatchingLabelCallCount() int {
	fake.deleteAllPodsMatchingLabelMutex.RLock()
	defer fake.deleteAllPodsMatchingLabelMutex.RUnlock()
	return len(fake.deleteAllPodsMatchingLabelArgsForCall)
}

func (fake *Kube) DeleteAllPodsMatchingLabelCalls(stub func(string, string) error) {
	fake.deleteAllPodsMatchingLabelMutex.Lock()
	defer fake.deleteAllPodsMatchingLabelMutex.Unlock()
	fake.DeleteAllPodsMatchingLabelStub = stub
}

func (fake *Kube) DeleteAllPodsMatchingLabelArgsForCall(i int) (string, string) {
	fake.deleteAllPodsMatchingLabelMutex.RLock()
	defer fake.deleteAllPodsMatchingLabelMutex.RUnlock()
	argsForCall := fake.deleteAllPodsMatchingLabelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) DeleteAllPodsMatchingLabelReturns(result1 error) {
	fake.deleteAllPodsMatchingLabelMutex.Lock()
	defer fake.deleteAllPodsMatchingLabelMutex.Unlock()
	fake.DeleteAllPodsMatchingLabelStub = nil
	fake.deleteAllPodsMatchingLabelReturns = struct {
		result1 error
	}{result1}
}

func (fake *Kube) DeleteAllPodsMatchingLabelReturnsOnCall(i int, result1 error) {
	fake.deleteAllPodsMatchingLabelMutex.Lock()
	defer fake.deleteAllPodsMatchingLabelMutex.Unlock()
	fake.DeleteAllPodsMatchingLabelStub = nil
	if fake.deleteAllPodsMatchingLabelReturnsOnCall == nil {
		fake.deleteAllPodsMatchingLabelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAllPodsMatchingLabelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Kube) DeleteAndCreatePod(arg1 string, arg2 *v1.Pod, arg3 string) (*v1.Pod, error) {
	fake.deleteAndCreatePodMutex.Lock()
	ret, specificReturn := fake.deleteAndCreatePodReturnsOnCall[len(fake.deleteAndCreatePodArgsForCall)]
	fake.deleteAndCreatePodArgsForCall = append(fake.deleteAndCreatePodArgsForCall, struct {
		arg1 string
		arg2 *v1.Pod
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DeleteAndCreatePodStub
	fakeReturns := fake.deleteAndCreatePodReturns
	fake.recordInvocation("DeleteAndCreatePod", []interface{}{arg1, arg2, arg3})
	fake.deleteAndCreatePodMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) DeleteAndCreatePodCallCount() int {
	fake.deleteAndCreatePodMutex.RLock()
	defer fake.deleteAndCreatePodMutex.RUnlock()
	return len(fake.deleteAndCreatePodArgsForCall)
}

func (fake *Kube) DeleteAndCreatePodCalls(stub func(string, *v1.Pod, string) (*v1.Pod, error)) {
	fake.deleteAndCreatePodMutex.Lock()
	defer fake.deleteAndCreatePodMutex.Unlock()
	fake.DeleteAndCreatePodStub = stub
}

func (fake *Kube) DeleteAndCreatePodArgsForCall(i int) (string, *v1.Pod, string) {
	fake.deleteAndCreatePodMutex.RLock()
	defer fake.deleteAndCreatePodMutex.RUnlock()
	argsForCall := fake.deleteAndCreatePodArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Kube) DeleteAndCreatePodReturns(result1 *v1.Pod, result2 error) {
	fake.deleteAndCreatePodMutex.Lock()
	defer fake.deleteAndCreatePodMutex.Unlock()
	fake.DeleteAndCreatePodStub = nil
	fake.deleteAndCreatePodReturns = struct {
		result1 *v1.Pod
		result2 error
	}{result1, result2}
}

func (fake *Kube) DeleteAndCreatePodReturnsOnCall(i int, result1 *v1.Pod, result2 error) {
	fake.deleteAndCreatePodMutex.Lock()
	defer fake.deleteAndCreatePodMutex.Unlock()
	fake.DeleteAndCreatePodStub = nil
	if fake.deleteAndCreatePodReturnsOnCall == nil {
		fake.deleteAndCreatePodReturnsOnCall = make(map[int]struct {
			result1 *v1.Pod
			result2 error
		})
	}
	fake.deleteAndCreatePodReturnsOnCall[i] = struct {
		result1 *v1.Pod
		result2 error
	}{result1, result2}
}

func (fake *Kube) DeleteService(arg1 string, arg2 string) error {
	fake.deleteServiceMutex.Lock()
	ret, specificReturn := fake.deleteServiceReturnsOnCall[len(fake.deleteServiceArgsForCall)]
	fake.deleteServiceArgsForCall = append(fake.deleteServiceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteServiceStub
	fakeReturns := fake.deleteServiceReturns
	fake.recordInvocation("DeleteService", []interface{}{arg1, arg2})
	fake.deleteServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Kube) DeleteServiceCallCount() int {
	fake.deleteServiceMutex.RLock()
	defer fake.deleteServiceMutex.RUnlock()
	return len(fake.deleteServiceArgsForCall)
}

func (fake *Kube) DeleteServiceCalls(stub func(string, string) error) {
	fake.deleteServiceMutex.Lock()
	defer fake.deleteServiceMutex.Unlock()
	fake.DeleteServiceStub = stub
}

func (fake *Kube) DeleteServiceArgsForCall(i int) (string, string) {
	fake.deleteServiceMutex.RLock()
	defer fake.deleteServiceMutex.RUnlock()
	argsForCall := fake.deleteServiceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) DeleteServiceReturns(result1 error) {
	fake.deleteServiceMutex.Lock()
	defer fake.deleteServiceMutex.Unlock()
	fake.DeleteServiceStub = nil
	fake.deleteServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *Kube) DeleteServiceReturnsOnCall(i int, result1 error) {
	fake.deleteServiceMutex.Lock()
	defer fake.deleteServiceMutex.Unlock()
	fake.DeleteServiceStub = nil
	if fake.deleteServiceReturnsOnCall == nil {
		fake.deleteServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Kube) GetPodsByLabel(arg1 string, arg2 string) (*v1.Pod, error) {
	fake.getPodsByLabelMutex.Lock()
	ret, specificReturn := fake.getPodsByLabelReturnsOnCall[len(fake.getPodsByLabelArgsForCall)]
	fake.getPodsByLabelArgsForCall = append(fake.getPodsByLabelArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetPodsByLabelStub
	fakeReturns := fake.getPodsByLabelReturns
	fake.recordInvocation("GetPodsByLabel", []interface{}{arg1, arg2})
	fake.getPodsByLabelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) GetPodsByLabelCallCount() int {
	fake.getPodsByLabelMutex.RLock()
	defer fake.getPodsByLabelMutex.RUnlock()
	return len(fake.getPodsByLabelArgsForCall)
}

func (fake *Kube) GetPodsByLabelCalls(stub func(string, string) (*v1.Pod, error)) {
	fake.getPodsByLabelMutex.Lock()
	defer fake.getPodsByLabelMutex.Unlock()
	fake.GetPodsByLabelStub = stub
}

func (fake *Kube) GetPodsByLabelArgsForCall(i int) (string, string) {
	fake.getPodsByLabelMutex.RLock()
	defer fake.getPodsByLabelMutex.RUnlock()
	argsForCall := fake.getPodsByLabelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) GetPodsByLabelReturns(result1 *v1.Pod, result2 error) {
	fake.getPodsByLabelMutex.Lock()
	defer fake.getPodsByLabelMutex.Unlock()
	fake.GetPodsByLabelStub = nil
	fake.getPodsByLabelReturns = struct {
		result1 *v1.Pod
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetPodsByLabelReturnsOnCall(i int, result1 *v1.Pod, result2 error) {
	fake.getPodsByLabelMutex.Lock()
	defer fake.getPodsByLabelMutex.Unlock()
	fake.GetPodsByLabelStub = nil
	if fake.getPodsByLabelReturnsOnCall == nil {
		fake.getPodsByLabelReturnsOnCall = make(map[int]struct {
			result1 *v1.Pod
			result2 error
		})
	}
	fake.getPodsByLabelReturnsOnCall[i] = struct {
		result1 *v1.Pod
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetService(arg1 string, arg2 string) (*v1.Service, error) {
	fake.getServiceMutex.Lock()
	ret, specificReturn := fake.getServiceReturnsOnCall[len(fake.getServiceArgsForCall)]
	fake.getServiceArgsForCall = append(fake.getServiceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetServiceStub
	fakeReturns := fake.getServiceReturns
	fake.recordInvocation("GetService", []interface{}{arg1, arg2})
	fake.getServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) GetServiceCallCount() int {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	return len(fake.getServiceArgsForCall)
}

func (fake *Kube) GetServiceCalls(stub func(string, string) (*v1.Service, error)) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = stub
}

func (fake *Kube) GetServiceArgsForCall(i int) (string, string) {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	argsForCall := fake.getServiceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) GetServiceReturns(result1 *v1.Service, result2 error) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = nil
	fake.getServiceReturns = struct {
		result1 *v1.Service
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetServiceReturnsOnCall(i int, result1 *v1.Service, result2 error) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = nil
	if fake.getServiceReturnsOnCall == nil {
		fake.getServiceReturnsOnCall = make(map[int]struct {
			result1 *v1.Service
			result2 error
		})
	}
	fake.getServiceReturnsOnCall[i] = struct {
		result1 *v1.Service
		result2 error
	}{result1, result2}
}

func (fake *Kube) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createConfigMapMutex.RLock()
	defer fake.createConfigMapMutex.RUnlock()
	fake.createServiceMutex.RLock()
	defer fake.createServiceMutex.RUnlock()
	fake.deleteAllPodsMatchingLabelMutex.RLock()
	defer fake.deleteAllPodsMatchingLabelMutex.RUnlock()
	fake.deleteAndCreatePodMutex.RLock()
	defer fake.deleteAndCreatePodMutex.RUnlock()
	fake.deleteServiceMutex.RLock()
	defer fake.deleteServiceMutex.RUnlock()
	fake.getPodsByLabelMutex.RLock()
	defer fake.getPodsByLabelMutex.RUnlock()
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Kube) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ mustgather.Kube = new(Kube)
