// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/IBM-Blockchain/fabric-deployer/deployer/components/orderer"
	v1 "k8s.io/api/core/v1"
)

type Kube struct {
	DeleteAndCreateSecretStub        func(string, *v1.Secret) (*v1.Secret, error)
	deleteAndCreateSecretMutex       sync.RWMutex
	deleteAndCreateSecretArgsForCall []struct {
		arg1 string
		arg2 *v1.Secret
	}
	deleteAndCreateSecretReturns struct {
		result1 *v1.Secret
		result2 error
	}
	deleteAndCreateSecretReturnsOnCall map[int]struct {
		result1 *v1.Secret
		result2 error
	}
	DeleteDeploymentStub        func(string, string) error
	deleteDeploymentMutex       sync.RWMutex
	deleteDeploymentArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteDeploymentReturns struct {
		result1 error
	}
	deleteDeploymentReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteSecretStub        func(string, string) error
	deleteSecretMutex       sync.RWMutex
	deleteSecretArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteSecretReturns struct {
		result1 error
	}
	deleteSecretReturnsOnCall map[int]struct {
		result1 error
	}
	GetConfigMapStub        func(string, string) (*v1.ConfigMap, error)
	getConfigMapMutex       sync.RWMutex
	getConfigMapArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getConfigMapReturns struct {
		result1 *v1.ConfigMap
		result2 error
	}
	getConfigMapReturnsOnCall map[int]struct {
		result1 *v1.ConfigMap
		result2 error
	}
	GetNamespacesStub        func() (*v1.NamespaceList, error)
	getNamespacesMutex       sync.RWMutex
	getNamespacesArgsForCall []struct {
	}
	getNamespacesReturns struct {
		result1 *v1.NamespaceList
		result2 error
	}
	getNamespacesReturnsOnCall map[int]struct {
		result1 *v1.NamespaceList
		result2 error
	}
	GetPodsByLabelStub        func(string, string) (*v1.Pod, error)
	getPodsByLabelMutex       sync.RWMutex
	getPodsByLabelArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getPodsByLabelReturns struct {
		result1 *v1.Pod
		result2 error
	}
	getPodsByLabelReturnsOnCall map[int]struct {
		result1 *v1.Pod
		result2 error
	}
	GetPortStub        func(string, string) (int32, error)
	getPortMutex       sync.RWMutex
	getPortArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getPortReturns struct {
		result1 int32
		result2 error
	}
	getPortReturnsOnCall map[int]struct {
		result1 int32
		result2 error
	}
	GetPortsStub        func(string, string) ([]v1.ServicePort, error)
	getPortsMutex       sync.RWMutex
	getPortsArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getPortsReturns struct {
		result1 []v1.ServicePort
		result2 error
	}
	getPortsReturnsOnCall map[int]struct {
		result1 []v1.ServicePort
		result2 error
	}
	GetSecretStub        func(string, string) (*v1.Secret, error)
	getSecretMutex       sync.RWMutex
	getSecretArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getSecretReturns struct {
		result1 *v1.Secret
		result2 error
	}
	getSecretReturnsOnCall map[int]struct {
		result1 *v1.Secret
		result2 error
	}
	GetServiceStub        func(string, string) (*v1.Service, error)
	getServiceMutex       sync.RWMutex
	getServiceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getServiceReturns struct {
		result1 *v1.Service
		result2 error
	}
	getServiceReturnsOnCall map[int]struct {
		result1 *v1.Service
		result2 error
	}
	UpdateSecretStub        func(string, string, string, []byte) (*v1.Secret, error)
	updateSecretMutex       sync.RWMutex
	updateSecretArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
	}
	updateSecretReturns struct {
		result1 *v1.Secret
		result2 error
	}
	updateSecretReturnsOnCall map[int]struct {
		result1 *v1.Secret
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Kube) DeleteAndCreateSecret(arg1 string, arg2 *v1.Secret) (*v1.Secret, error) {
	fake.deleteAndCreateSecretMutex.Lock()
	ret, specificReturn := fake.deleteAndCreateSecretReturnsOnCall[len(fake.deleteAndCreateSecretArgsForCall)]
	fake.deleteAndCreateSecretArgsForCall = append(fake.deleteAndCreateSecretArgsForCall, struct {
		arg1 string
		arg2 *v1.Secret
	}{arg1, arg2})
	stub := fake.DeleteAndCreateSecretStub
	fakeReturns := fake.deleteAndCreateSecretReturns
	fake.recordInvocation("DeleteAndCreateSecret", []interface{}{arg1, arg2})
	fake.deleteAndCreateSecretMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) DeleteAndCreateSecretCallCount() int {
	fake.deleteAndCreateSecretMutex.RLock()
	defer fake.deleteAndCreateSecretMutex.RUnlock()
	return len(fake.deleteAndCreateSecretArgsForCall)
}

func (fake *Kube) DeleteAndCreateSecretCalls(stub func(string, *v1.Secret) (*v1.Secret, error)) {
	fake.deleteAndCreateSecretMutex.Lock()
	defer fake.deleteAndCreateSecretMutex.Unlock()
	fake.DeleteAndCreateSecretStub = stub
}

func (fake *Kube) DeleteAndCreateSecretArgsForCall(i int) (string, *v1.Secret) {
	fake.deleteAndCreateSecretMutex.RLock()
	defer fake.deleteAndCreateSecretMutex.RUnlock()
	argsForCall := fake.deleteAndCreateSecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) DeleteAndCreateSecretReturns(result1 *v1.Secret, result2 error) {
	fake.deleteAndCreateSecretMutex.Lock()
	defer fake.deleteAndCreateSecretMutex.Unlock()
	fake.DeleteAndCreateSecretStub = nil
	fake.deleteAndCreateSecretReturns = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *Kube) DeleteAndCreateSecretReturnsOnCall(i int, result1 *v1.Secret, result2 error) {
	fake.deleteAndCreateSecretMutex.Lock()
	defer fake.deleteAndCreateSecretMutex.Unlock()
	fake.DeleteAndCreateSecretStub = nil
	if fake.deleteAndCreateSecretReturnsOnCall == nil {
		fake.deleteAndCreateSecretReturnsOnCall = make(map[int]struct {
			result1 *v1.Secret
			result2 error
		})
	}
	fake.deleteAndCreateSecretReturnsOnCall[i] = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *Kube) DeleteDeployment(arg1 string, arg2 string) error {
	fake.deleteDeploymentMutex.Lock()
	ret, specificReturn := fake.deleteDeploymentReturnsOnCall[len(fake.deleteDeploymentArgsForCall)]
	fake.deleteDeploymentArgsForCall = append(fake.deleteDeploymentArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteDeploymentStub
	fakeReturns := fake.deleteDeploymentReturns
	fake.recordInvocation("DeleteDeployment", []interface{}{arg1, arg2})
	fake.deleteDeploymentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Kube) DeleteDeploymentCallCount() int {
	fake.deleteDeploymentMutex.RLock()
	defer fake.deleteDeploymentMutex.RUnlock()
	return len(fake.deleteDeploymentArgsForCall)
}

func (fake *Kube) DeleteDeploymentCalls(stub func(string, string) error) {
	fake.deleteDeploymentMutex.Lock()
	defer fake.deleteDeploymentMutex.Unlock()
	fake.DeleteDeploymentStub = stub
}

func (fake *Kube) DeleteDeploymentArgsForCall(i int) (string, string) {
	fake.deleteDeploymentMutex.RLock()
	defer fake.deleteDeploymentMutex.RUnlock()
	argsForCall := fake.deleteDeploymentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) DeleteDeploymentReturns(result1 error) {
	fake.deleteDeploymentMutex.Lock()
	defer fake.deleteDeploymentMutex.Unlock()
	fake.DeleteDeploymentStub = nil
	fake.deleteDeploymentReturns = struct {
		result1 error
	}{result1}
}

func (fake *Kube) DeleteDeploymentReturnsOnCall(i int, result1 error) {
	fake.deleteDeploymentMutex.Lock()
	defer fake.deleteDeploymentMutex.Unlock()
	fake.DeleteDeploymentStub = nil
	if fake.deleteDeploymentReturnsOnCall == nil {
		fake.deleteDeploymentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteDeploymentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Kube) DeleteSecret(arg1 string, arg2 string) error {
	fake.deleteSecretMutex.Lock()
	ret, specificReturn := fake.deleteSecretReturnsOnCall[len(fake.deleteSecretArgsForCall)]
	fake.deleteSecretArgsForCall = append(fake.deleteSecretArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteSecretStub
	fakeReturns := fake.deleteSecretReturns
	fake.recordInvocation("DeleteSecret", []interface{}{arg1, arg2})
	fake.deleteSecretMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Kube) DeleteSecretCallCount() int {
	fake.deleteSecretMutex.RLock()
	defer fake.deleteSecretMutex.RUnlock()
	return len(fake.deleteSecretArgsForCall)
}

func (fake *Kube) DeleteSecretCalls(stub func(string, string) error) {
	fake.deleteSecretMutex.Lock()
	defer fake.deleteSecretMutex.Unlock()
	fake.DeleteSecretStub = stub
}

func (fake *Kube) DeleteSecretArgsForCall(i int) (string, string) {
	fake.deleteSecretMutex.RLock()
	defer fake.deleteSecretMutex.RUnlock()
	argsForCall := fake.deleteSecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) DeleteSecretReturns(result1 error) {
	fake.deleteSecretMutex.Lock()
	defer fake.deleteSecretMutex.Unlock()
	fake.DeleteSecretStub = nil
	fake.deleteSecretReturns = struct {
		result1 error
	}{result1}
}

func (fake *Kube) DeleteSecretReturnsOnCall(i int, result1 error) {
	fake.deleteSecretMutex.Lock()
	defer fake.deleteSecretMutex.Unlock()
	fake.DeleteSecretStub = nil
	if fake.deleteSecretReturnsOnCall == nil {
		fake.deleteSecretReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSecretReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Kube) GetConfigMap(arg1 string, arg2 string) (*v1.ConfigMap, error) {
	fake.getConfigMapMutex.Lock()
	ret, specificReturn := fake.getConfigMapReturnsOnCall[len(fake.getConfigMapArgsForCall)]
	fake.getConfigMapArgsForCall = append(fake.getConfigMapArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetConfigMapStub
	fakeReturns := fake.getConfigMapReturns
	fake.recordInvocation("GetConfigMap", []interface{}{arg1, arg2})
	fake.getConfigMapMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) GetConfigMapCallCount() int {
	fake.getConfigMapMutex.RLock()
	defer fake.getConfigMapMutex.RUnlock()
	return len(fake.getConfigMapArgsForCall)
}

func (fake *Kube) GetConfigMapCalls(stub func(string, string) (*v1.ConfigMap, error)) {
	fake.getConfigMapMutex.Lock()
	defer fake.getConfigMapMutex.Unlock()
	fake.GetConfigMapStub = stub
}

func (fake *Kube) GetConfigMapArgsForCall(i int) (string, string) {
	fake.getConfigMapMutex.RLock()
	defer fake.getConfigMapMutex.RUnlock()
	argsForCall := fake.getConfigMapArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) GetConfigMapReturns(result1 *v1.ConfigMap, result2 error) {
	fake.getConfigMapMutex.Lock()
	defer fake.getConfigMapMutex.Unlock()
	fake.GetConfigMapStub = nil
	fake.getConfigMapReturns = struct {
		result1 *v1.ConfigMap
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetConfigMapReturnsOnCall(i int, result1 *v1.ConfigMap, result2 error) {
	fake.getConfigMapMutex.Lock()
	defer fake.getConfigMapMutex.Unlock()
	fake.GetConfigMapStub = nil
	if fake.getConfigMapReturnsOnCall == nil {
		fake.getConfigMapReturnsOnCall = make(map[int]struct {
			result1 *v1.ConfigMap
			result2 error
		})
	}
	fake.getConfigMapReturnsOnCall[i] = struct {
		result1 *v1.ConfigMap
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetNamespaces() (*v1.NamespaceList, error) {
	fake.getNamespacesMutex.Lock()
	ret, specificReturn := fake.getNamespacesReturnsOnCall[len(fake.getNamespacesArgsForCall)]
	fake.getNamespacesArgsForCall = append(fake.getNamespacesArgsForCall, struct {
	}{})
	stub := fake.GetNamespacesStub
	fakeReturns := fake.getNamespacesReturns
	fake.recordInvocation("GetNamespaces", []interface{}{})
	fake.getNamespacesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) GetNamespacesCallCount() int {
	fake.getNamespacesMutex.RLock()
	defer fake.getNamespacesMutex.RUnlock()
	return len(fake.getNamespacesArgsForCall)
}

func (fake *Kube) GetNamespacesCalls(stub func() (*v1.NamespaceList, error)) {
	fake.getNamespacesMutex.Lock()
	defer fake.getNamespacesMutex.Unlock()
	fake.GetNamespacesStub = stub
}

func (fake *Kube) GetNamespacesReturns(result1 *v1.NamespaceList, result2 error) {
	fake.getNamespacesMutex.Lock()
	defer fake.getNamespacesMutex.Unlock()
	fake.GetNamespacesStub = nil
	fake.getNamespacesReturns = struct {
		result1 *v1.NamespaceList
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetNamespacesReturnsOnCall(i int, result1 *v1.NamespaceList, result2 error) {
	fake.getNamespacesMutex.Lock()
	defer fake.getNamespacesMutex.Unlock()
	fake.GetNamespacesStub = nil
	if fake.getNamespacesReturnsOnCall == nil {
		fake.getNamespacesReturnsOnCall = make(map[int]struct {
			result1 *v1.NamespaceList
			result2 error
		})
	}
	fake.getNamespacesReturnsOnCall[i] = struct {
		result1 *v1.NamespaceList
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetPodsByLabel(arg1 string, arg2 string) (*v1.Pod, error) {
	fake.getPodsByLabelMutex.Lock()
	ret, specificReturn := fake.getPodsByLabelReturnsOnCall[len(fake.getPodsByLabelArgsForCall)]
	fake.getPodsByLabelArgsForCall = append(fake.getPodsByLabelArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetPodsByLabelStub
	fakeReturns := fake.getPodsByLabelReturns
	fake.recordInvocation("GetPodsByLabel", []interface{}{arg1, arg2})
	fake.getPodsByLabelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) GetPodsByLabelCallCount() int {
	fake.getPodsByLabelMutex.RLock()
	defer fake.getPodsByLabelMutex.RUnlock()
	return len(fake.getPodsByLabelArgsForCall)
}

func (fake *Kube) GetPodsByLabelCalls(stub func(string, string) (*v1.Pod, error)) {
	fake.getPodsByLabelMutex.Lock()
	defer fake.getPodsByLabelMutex.Unlock()
	fake.GetPodsByLabelStub = stub
}

func (fake *Kube) GetPodsByLabelArgsForCall(i int) (string, string) {
	fake.getPodsByLabelMutex.RLock()
	defer fake.getPodsByLabelMutex.RUnlock()
	argsForCall := fake.getPodsByLabelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) GetPodsByLabelReturns(result1 *v1.Pod, result2 error) {
	fake.getPodsByLabelMutex.Lock()
	defer fake.getPodsByLabelMutex.Unlock()
	fake.GetPodsByLabelStub = nil
	fake.getPodsByLabelReturns = struct {
		result1 *v1.Pod
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetPodsByLabelReturnsOnCall(i int, result1 *v1.Pod, result2 error) {
	fake.getPodsByLabelMutex.Lock()
	defer fake.getPodsByLabelMutex.Unlock()
	fake.GetPodsByLabelStub = nil
	if fake.getPodsByLabelReturnsOnCall == nil {
		fake.getPodsByLabelReturnsOnCall = make(map[int]struct {
			result1 *v1.Pod
			result2 error
		})
	}
	fake.getPodsByLabelReturnsOnCall[i] = struct {
		result1 *v1.Pod
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetPort(arg1 string, arg2 string) (int32, error) {
	fake.getPortMutex.Lock()
	ret, specificReturn := fake.getPortReturnsOnCall[len(fake.getPortArgsForCall)]
	fake.getPortArgsForCall = append(fake.getPortArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetPortStub
	fakeReturns := fake.getPortReturns
	fake.recordInvocation("GetPort", []interface{}{arg1, arg2})
	fake.getPortMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) GetPortCallCount() int {
	fake.getPortMutex.RLock()
	defer fake.getPortMutex.RUnlock()
	return len(fake.getPortArgsForCall)
}

func (fake *Kube) GetPortCalls(stub func(string, string) (int32, error)) {
	fake.getPortMutex.Lock()
	defer fake.getPortMutex.Unlock()
	fake.GetPortStub = stub
}

func (fake *Kube) GetPortArgsForCall(i int) (string, string) {
	fake.getPortMutex.RLock()
	defer fake.getPortMutex.RUnlock()
	argsForCall := fake.getPortArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) GetPortReturns(result1 int32, result2 error) {
	fake.getPortMutex.Lock()
	defer fake.getPortMutex.Unlock()
	fake.GetPortStub = nil
	fake.getPortReturns = struct {
		result1 int32
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetPortReturnsOnCall(i int, result1 int32, result2 error) {
	fake.getPortMutex.Lock()
	defer fake.getPortMutex.Unlock()
	fake.GetPortStub = nil
	if fake.getPortReturnsOnCall == nil {
		fake.getPortReturnsOnCall = make(map[int]struct {
			result1 int32
			result2 error
		})
	}
	fake.getPortReturnsOnCall[i] = struct {
		result1 int32
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetPorts(arg1 string, arg2 string) ([]v1.ServicePort, error) {
	fake.getPortsMutex.Lock()
	ret, specificReturn := fake.getPortsReturnsOnCall[len(fake.getPortsArgsForCall)]
	fake.getPortsArgsForCall = append(fake.getPortsArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetPortsStub
	fakeReturns := fake.getPortsReturns
	fake.recordInvocation("GetPorts", []interface{}{arg1, arg2})
	fake.getPortsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) GetPortsCallCount() int {
	fake.getPortsMutex.RLock()
	defer fake.getPortsMutex.RUnlock()
	return len(fake.getPortsArgsForCall)
}

func (fake *Kube) GetPortsCalls(stub func(string, string) ([]v1.ServicePort, error)) {
	fake.getPortsMutex.Lock()
	defer fake.getPortsMutex.Unlock()
	fake.GetPortsStub = stub
}

func (fake *Kube) GetPortsArgsForCall(i int) (string, string) {
	fake.getPortsMutex.RLock()
	defer fake.getPortsMutex.RUnlock()
	argsForCall := fake.getPortsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) GetPortsReturns(result1 []v1.ServicePort, result2 error) {
	fake.getPortsMutex.Lock()
	defer fake.getPortsMutex.Unlock()
	fake.GetPortsStub = nil
	fake.getPortsReturns = struct {
		result1 []v1.ServicePort
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetPortsReturnsOnCall(i int, result1 []v1.ServicePort, result2 error) {
	fake.getPortsMutex.Lock()
	defer fake.getPortsMutex.Unlock()
	fake.GetPortsStub = nil
	if fake.getPortsReturnsOnCall == nil {
		fake.getPortsReturnsOnCall = make(map[int]struct {
			result1 []v1.ServicePort
			result2 error
		})
	}
	fake.getPortsReturnsOnCall[i] = struct {
		result1 []v1.ServicePort
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetSecret(arg1 string, arg2 string) (*v1.Secret, error) {
	fake.getSecretMutex.Lock()
	ret, specificReturn := fake.getSecretReturnsOnCall[len(fake.getSecretArgsForCall)]
	fake.getSecretArgsForCall = append(fake.getSecretArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetSecretStub
	fakeReturns := fake.getSecretReturns
	fake.recordInvocation("GetSecret", []interface{}{arg1, arg2})
	fake.getSecretMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) GetSecretCallCount() int {
	fake.getSecretMutex.RLock()
	defer fake.getSecretMutex.RUnlock()
	return len(fake.getSecretArgsForCall)
}

func (fake *Kube) GetSecretCalls(stub func(string, string) (*v1.Secret, error)) {
	fake.getSecretMutex.Lock()
	defer fake.getSecretMutex.Unlock()
	fake.GetSecretStub = stub
}

func (fake *Kube) GetSecretArgsForCall(i int) (string, string) {
	fake.getSecretMutex.RLock()
	defer fake.getSecretMutex.RUnlock()
	argsForCall := fake.getSecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) GetSecretReturns(result1 *v1.Secret, result2 error) {
	fake.getSecretMutex.Lock()
	defer fake.getSecretMutex.Unlock()
	fake.GetSecretStub = nil
	fake.getSecretReturns = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetSecretReturnsOnCall(i int, result1 *v1.Secret, result2 error) {
	fake.getSecretMutex.Lock()
	defer fake.getSecretMutex.Unlock()
	fake.GetSecretStub = nil
	if fake.getSecretReturnsOnCall == nil {
		fake.getSecretReturnsOnCall = make(map[int]struct {
			result1 *v1.Secret
			result2 error
		})
	}
	fake.getSecretReturnsOnCall[i] = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetService(arg1 string, arg2 string) (*v1.Service, error) {
	fake.getServiceMutex.Lock()
	ret, specificReturn := fake.getServiceReturnsOnCall[len(fake.getServiceArgsForCall)]
	fake.getServiceArgsForCall = append(fake.getServiceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetServiceStub
	fakeReturns := fake.getServiceReturns
	fake.recordInvocation("GetService", []interface{}{arg1, arg2})
	fake.getServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) GetServiceCallCount() int {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	return len(fake.getServiceArgsForCall)
}

func (fake *Kube) GetServiceCalls(stub func(string, string) (*v1.Service, error)) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = stub
}

func (fake *Kube) GetServiceArgsForCall(i int) (string, string) {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	argsForCall := fake.getServiceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Kube) GetServiceReturns(result1 *v1.Service, result2 error) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = nil
	fake.getServiceReturns = struct {
		result1 *v1.Service
		result2 error
	}{result1, result2}
}

func (fake *Kube) GetServiceReturnsOnCall(i int, result1 *v1.Service, result2 error) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = nil
	if fake.getServiceReturnsOnCall == nil {
		fake.getServiceReturnsOnCall = make(map[int]struct {
			result1 *v1.Service
			result2 error
		})
	}
	fake.getServiceReturnsOnCall[i] = struct {
		result1 *v1.Service
		result2 error
	}{result1, result2}
}

func (fake *Kube) UpdateSecret(arg1 string, arg2 string, arg3 string, arg4 []byte) (*v1.Secret, error) {
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.updateSecretMutex.Lock()
	ret, specificReturn := fake.updateSecretReturnsOnCall[len(fake.updateSecretArgsForCall)]
	fake.updateSecretArgsForCall = append(fake.updateSecretArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.UpdateSecretStub
	fakeReturns := fake.updateSecretReturns
	fake.recordInvocation("UpdateSecret", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.updateSecretMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Kube) UpdateSecretCallCount() int {
	fake.updateSecretMutex.RLock()
	defer fake.updateSecretMutex.RUnlock()
	return len(fake.updateSecretArgsForCall)
}

func (fake *Kube) UpdateSecretCalls(stub func(string, string, string, []byte) (*v1.Secret, error)) {
	fake.updateSecretMutex.Lock()
	defer fake.updateSecretMutex.Unlock()
	fake.UpdateSecretStub = stub
}

func (fake *Kube) UpdateSecretArgsForCall(i int) (string, string, string, []byte) {
	fake.updateSecretMutex.RLock()
	defer fake.updateSecretMutex.RUnlock()
	argsForCall := fake.updateSecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *Kube) UpdateSecretReturns(result1 *v1.Secret, result2 error) {
	fake.updateSecretMutex.Lock()
	defer fake.updateSecretMutex.Unlock()
	fake.UpdateSecretStub = nil
	fake.updateSecretReturns = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *Kube) UpdateSecretReturnsOnCall(i int, result1 *v1.Secret, result2 error) {
	fake.updateSecretMutex.Lock()
	defer fake.updateSecretMutex.Unlock()
	fake.UpdateSecretStub = nil
	if fake.updateSecretReturnsOnCall == nil {
		fake.updateSecretReturnsOnCall = make(map[int]struct {
			result1 *v1.Secret
			result2 error
		})
	}
	fake.updateSecretReturnsOnCall[i] = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *Kube) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteAndCreateSecretMutex.RLock()
	defer fake.deleteAndCreateSecretMutex.RUnlock()
	fake.deleteDeploymentMutex.RLock()
	defer fake.deleteDeploymentMutex.RUnlock()
	fake.deleteSecretMutex.RLock()
	defer fake.deleteSecretMutex.RUnlock()
	fake.getConfigMapMutex.RLock()
	defer fake.getConfigMapMutex.RUnlock()
	fake.getNamespacesMutex.RLock()
	defer fake.getNamespacesMutex.RUnlock()
	fake.getPodsByLabelMutex.RLock()
	defer fake.getPodsByLabelMutex.RUnlock()
	fake.getPortMutex.RLock()
	defer fake.getPortMutex.RUnlock()
	fake.getPortsMutex.RLock()
	defer fake.getPortsMutex.RUnlock()
	fake.getSecretMutex.RLock()
	defer fake.getSecretMutex.RUnlock()
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	fake.updateSecretMutex.RLock()
	defer fake.updateSecretMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Kube) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ orderer.Kube = new(Kube)
