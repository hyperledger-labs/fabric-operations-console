/*
 * Copyright contributors to the Hyperledger Fabric Operations Console project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

// Libs built by us
import { logger, uint8ArrayToStr, base64ToUint8Array } from './misc';

// exports
export { pbToJson, jsonToPb, calculateConfigUpdatePb };

// NOTE:
// Error handling/detecting with configtxlator is a bit strange.
// It will send text back instead of json.
// The Fetch API does not like mixed responses (sometimes json sometimes text), thus the code gets a bit odd.

const v_types = [
	'LastConfig', 'Metadata', 'MetadataSignature', 'Header', 'ChannelHeader', 'SignatureHeader', 'Payload',
	'Envelope', 'Block', 'BlockHeader', 'BlockData', 'BlockMetadata', 'Config', 'ConfigEnvelope', 'ConfigUpdate'
];

// --------------------------------------------------------------------------------
// Protobuf => JSON via configtxlator
// --------------------------------------------------------------------------------
/*
	opts: {
		cfxl_host: 'https://configtxlator.com:8122',					// http endpoint to a configtxlator, include protocol and port
		data: <Uint8Array>,
		message_type: 'Block' || 'LastConfig' || 'ChannelHeader' etc..
	}
*/
function pbToJson(opts: Cds, cb: Function) {
	if (!opts.cfxl_host) { logger.warn('[stitch] missing required parameter "cfxl_host"'); }
	if (!opts.data) { logger.warn('[stitch] missing required parameter "data"'); }
	if (!opts.message_type) { logger.warn('[stitch] missing required parameter "message_type"'); }
	if (opts.message_type && v_types.indexOf(opts.message_type) === -1) { logger.warn('[stitch] parameter "message_type" is not a valid type. try:', v_types); }

	const err_obj = {
		function_name: 'pbToJson',
		error: true,
		stitch_msg: '',
		status_code: 500,
	};

	if (typeof opts.data === 'string') {
		opts.data = base64ToUint8Array(opts.data);
	}

	// decoding takes pb -> json
	const options: In_Cds = {
		...opts,
		url: opts.cfxl_host + '/protolator/decode/common.' + opts.message_type
	};
	postBlob(options).then(response => {
		const json = response._parsed;
		if (typeof json === 'string') {								// if its not json its an error
			err_obj.stitch_msg = response._parsed;
			err_obj.status_code = response.status;
			return cb(err_obj, null);
		} else {
			return cb(null, json);
		}
	}).catch(error => {												// likely isn't possible to get here
		if (error instanceof Error) {
			error = error.toString();
		}
		err_obj.stitch_msg = error;
		err_obj.status_code = 499;
		return cb(err_obj, null);
	});
}

// --------------------------------------------------------------------------------
// JSON => Protobuf via configtxlator - note the json generated by protoc is not consumable by configtxlator!
// --------------------------------------------------------------------------------
/*
	opts: {
		cfxl_host: 'https://configtxlator.com:8122',					// http endpoint to a configtxlator, include protocol and port
		data: {},
		message_type: 'Block' || 'LastConfig' || 'ChannelHeader' etc..
	}
*/
function jsonToPb(opts: Cds, cb: Function) {
	if (!opts.cfxl_host) { logger.warn('[stitch] missing required parameter "cfxl_host"'); }
	if (!opts.data) { logger.warn('[stitch] missing required parameter "data"'); }
	if (!opts.message_type) { logger.warn('[stitch] missing required parameter "message_type"'); }
	if (opts.message_type && v_types.indexOf(opts.message_type) === -1) { logger.warn('[stitch] parameter "message_type" is not a valid type. try:', v_types); }

	const err_obj = {
		function_name: 'jsonToPb',
		error: true,
		stitch_msg: '',
		status_code: 500,
	};

	const options: In_Cds = {
		...opts,
		url: opts.cfxl_host + '/protolator/encode/common.' + opts.message_type
	};
	postJSON(options).then(response => {
		const blob = response._parsed;
		if (typeof blob === 'string') {									// error response
			err_obj.stitch_msg = response._parsed;
			err_obj.status_code = response.status;
			cb(err_obj, null);
		} else {
			const reader = new FileReader();
			reader.addEventListener('loadend', (e: any) => {
				return cb(null, new Uint8Array(e.srcElement.result));
			});
			reader.readAsArrayBuffer(blob);
		}
	}).catch(error => {													// likely isn't possible to get here
		if (error instanceof Error) {
			error = error.toString();
		}
		err_obj.stitch_msg = error;
		err_obj.status_code = 499;
		return cb(err_obj, null);
	});
}

// --------------------------------------------------------------------------------
// Config Update Calculation - aka delta calculation. send the desired "after" config block and the before block. returns binary
// --------------------------------------------------------------------------------
/*
	opts: {
		cfxl_host: configtxlator_url,
		original_json: stitch.camelCase_2_underscores(block.data.data[0].payload.data.config),
		updated_json: stitch.camelCase_2_underscores(updated.data.data[0].payload.data.config),
		channel_id: 'testchainid',
	}
*/
function calculateConfigUpdatePb(opts: Dds, cb: Function) {
	encodeMessageBlob(opts.original_json, opts.cfxl_host, 'common.Config', (err1: any, original_proto: Blob) => {
		if (err1 || !original_proto) {
			return cb(err1, null);
		} else {
			encodeMessageBlob(opts.updated_json, opts.cfxl_host, 'common.Config', (err2: any, updated_proto: Blob) => {
				if (err2 || !updated_proto) {
					return cb(err2, null);
				} else {
					let formData = new FormData();
					formData.append('channel', opts.channel_id);
					formData.append('original', original_proto, 'original.pb');
					formData.append('updated', updated_proto, 'updated_proto.pb');

					fetch(opts.cfxl_host + '/configtxlator/compute/update-from-configs', {
						method: 'POST',
						body: formData,
						mode: 'cors',
						cache: 'no-cache',
						credentials: 'same-origin',
						redirect: 'follow',
						referrer: 'no-referrer',
					}).then(res => {
						return res.blob();
					}).then(response => {
						if (response.type === 'text/plain') {							// error response
							const reader = new FileReader();
							reader.addEventListener('loadend', e => {
								logger.error('[stitch] error calculating pb delta', reader.result);
								return cb(reader.result, null);
							});
							reader.readAsText(response);
						} else {
							const reader = new FileReader();
							reader.addEventListener('loadend', e => {
								const bin = new Uint8Array(<any>reader.result);
								const resp_as_str = uint8ArrayToStr(bin);
								if (resp_as_str.includes('Error computing update')) {
									logger.error('[stitch] error calculating pb delta', resp_as_str);
									return cb(resp_as_str, null);
								} else {
									return cb(null, bin);
								}
							});
							reader.readAsArrayBuffer(response);
						}
					}).catch(error => {
						logger.error('[stitch] error in calculateConfigUpdatePb', error);
						return cb(error, null);
					});
				}
			});
		}
	});

	function encodeMessageBlob(json: any, configtxlator: string, message_name: string, cb_encode: Function) {
		fetch(configtxlator + '/protolator/encode/' + message_name, {
			method: 'POST',
			mode: 'cors',
			credentials: 'same-origin',
			body: JSON.stringify(json),
		}).then(res => {
			return res.blob();
		}).then(response => {
			if (response.type === 'text/plain') {								// error response
				const reader = new FileReader();
				reader.addEventListener('loadend', e => {
					return cb_encode(reader.result, null);
				});
				reader.readAsText(response);
			} else {
				return cb_encode(null, response);
			}
		}).catch(error => {
			return cb_encode(error, null);
		});
	}
}

// --------------------------------------------------------------------------------
// Post some binary data (as is) onward via Fetch - expects JSON back
// --------------------------------------------------------------------------------
/*
	opts: {
		url: 'https://configtxlator.com:8122',			// http endpoint to a configtxlator, include protocol and port
		data: <Uint8Array>
	}
*/
async function postBlob(opts: any) {
	return fetch(opts.url, {			// Default options are marked with *
		method: 'POST',
		mode: 'cors', 					// no-cors, cors, *same-origin - [do not use "no-cors" you cannot read the body in the response]
		cache: 'no-cache', 				// *default, no-cache, reload, force-cache, only-if-cached
		credentials: 'same-origin', 	// include, same-origin, *omit
		/*headers: {
			'Content-Type': 'application/octet-stream',		// [content-type doesn't set when the body is a byte array[]
		},*/
		redirect: 'follow', 			// manual, *follow, error
		referrer: 'no-referrer', 		// no-referrer, *client
		body: opts.data,
	}).then(async response => {			// try to parse the response
		if (!response.ok) {
			throw response;				// whoops something broke
		}
		const ret = <any>response;
		ret._parsed = await response.json();// parse it as json
		return ret;
	}).catch(async err => {
		const ret = <any>err;
		if (err && err.text) {				// if there's an error message, get it
			ret._parsed = await err.text();
			return ret;
		} else {
			if (err instanceof Error) {
				ret._parsed = err.toString();
			}
			return ret;
		}
	});
}

// --------------------------------------------------------------------------------
// Post some JSON data onward via Fetch - returns bin if successful, string if error
// --------------------------------------------------------------------------------
/*
	opts: {
		url: 'https://configtxlator.com:8122',			// http endpoint to a configtxlator, include protocol and port
		data: {}
	}
*/
async function postJSON(opts: any) {
	return fetch(opts.url, {				// Default options are marked with *
		method: 'POST',
		mode: 'cors', 						// cors, *same-origin
		cache: 'no-cache', 					// *default, no-cache, reload, force-cache, only-if-cached
		credentials: 'same-origin', 		// include, same-origin, *omit
		//headers: {
		///	'Content-Type': 'application/json; charset=utf-8', 	// [do not set this, configtxlator will not send CORs headers if content-type is set...]
		//},
		redirect: 'follow', 				// manual, *follow, error
		referrer: 'no-referrer', 			// no-referrer, *client
		body: JSON.stringify(opts.data), 	// body data type must match 'Content-Type' header
	}).then(async response => {					// try to parse the response
		if (!response.ok) {
			throw response;					// whoops something broke
		}
		const ret = <any>response;
		ret._parsed = await response.blob();// parse it as a blob
		return ret;
	}).catch(async err => {
		const ret = <any>err;
		if (err && err.text) {				// if there's an error message, get it
			ret._parsed = await err.text();
			return ret;
		} else {
			if (err instanceof Error) {
				ret._parsed = err.toString();
			}
			return ret;
		}
	});
}


interface Cds {
	data: Uint8Array;
	cfxl_host: string;
	message_type: string;
}

interface In_Cds extends Cds {
	url: string;		// this field gets built, set as null
}

interface Dds {
	cfxl_host: string;
	original_json: any;
	updated_json: any;
	channel_id: string;
}
